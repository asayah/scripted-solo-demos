// Code generated by Autopilot. DO NOT EDIT.

package scheduler

import (
	"context"
	"fmt"
	"reflect"
	"time"

	"github.com/go-logr/logr"
	"github.com/golang/protobuf/ptypes"

	"k8s.io/apimachinery/pkg/api/errors"

	ctl "sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/controller"
	"sigs.k8s.io/controller-runtime/pkg/handler"
	"sigs.k8s.io/controller-runtime/pkg/manager"
	"sigs.k8s.io/controller-runtime/pkg/reconcile"
	"sigs.k8s.io/controller-runtime/pkg/source"

	"github.com/solo-io/autopilot/pkg/config"
	"github.com/solo-io/autopilot/pkg/ezkube"
	"github.com/solo-io/autopilot/pkg/scheduler"

	v1 "autorouter.example.io/pkg/apis/autoroutes/v1"
	initializing "autorouter.example.io/pkg/workers/initializing"
	ready "autorouter.example.io/pkg/workers/ready"
	syncing "autorouter.example.io/pkg/workers/syncing"
	istiov1alpha3 "istio.io/client-go/pkg/apis/networking/v1alpha3"
	corev1 "k8s.io/api/core/v1"
)

func AddToManager(params scheduler.Params) error {
	scheduler, err := NewScheduler(params)
	if err != nil {
		return err
	}
	// Create a new controller
	c, err := controller.New("autoRoute-controller", params.Manager, controller.Options{Reconciler: scheduler})
	if err != nil {
		return err
	}

	// Watch for changes to primary resource AutoRoute
	params.Logger.Info("Registering watch for primary resource AutoRoute")
	err = c.Watch(&source.Kind{Type: &v1.AutoRoute{}}, &handler.EnqueueRequestForObject{})
	if err != nil {
		return err
	}

	// Watch for changes to output resource Services and requeue the owner AutoRoute
	params.Logger.Info("Registering watch for output resource Services")
	err = c.Watch(&source.Kind{Type: &corev1.Service{}}, &handler.EnqueueRequestForOwner{
		IsController: true,
		OwnerType:    &v1.AutoRoute{},
	})
	if err != nil {
		return err
	}

	// Watch for changes to output resource VirtualServices and requeue the owner AutoRoute
	params.Logger.Info("Registering watch for output resource VirtualServices")
	err = c.Watch(&source.Kind{Type: &istiov1alpha3.VirtualService{}}, &handler.EnqueueRequestForOwner{
		IsController: true,
		OwnerType:    &v1.AutoRoute{},
	})
	if err != nil {
		return err
	}

	// Watch for changes to output resource Gateways and requeue the owner AutoRoute
	params.Logger.Info("Registering watch for output resource Gateways")
	err = c.Watch(&source.Kind{Type: &istiov1alpha3.Gateway{}}, &handler.EnqueueRequestForOwner{
		IsController: true,
		OwnerType:    &v1.AutoRoute{},
	})
	if err != nil {
		return err
	}

	return nil

}

type Scheduler struct {
	ctx          context.Context
	mgr          manager.Manager
	namespace    string
	logger       logr.Logger
	workInterval time.Duration
}

func NewScheduler(params scheduler.Params) (*Scheduler, error) {
	cfg := config.ConfigFromContext(params.Ctx)

	workInterval, err := ptypes.Duration(cfg.WorkInterval)
	if err != nil {
		return nil, err
	}

	return &Scheduler{
		ctx:          params.Ctx,
		mgr:          params.Manager,
		namespace:    params.Namespace,
		logger:       params.Logger,
		workInterval: workInterval,
	}, nil
}

func (s *Scheduler) Reconcile(request reconcile.Request) (reconcile.Result, error) {
	result := reconcile.Result{RequeueAfter: s.workInterval}

	autoRoute := &v1.AutoRoute{}
	autoRoute.Namespace = request.Namespace
	autoRoute.Name = request.Name

	client := ezkube.NewClient(s.mgr)

	if err := client.Get(s.ctx, autoRoute); err != nil {
		// garbage collection and finalizers should handle cleaning up after deletion
		if errors.IsNotFound(err) {
			return result, nil
		}
		return result, fmt.Errorf("failed to retrieve requested AutoRoute: %v", err)
	}

	// store original status for comparison after sync
	status := autoRoute.Status

	logger := s.logger.WithValues(
		"autoRoute", autoRoute.Namespace+"."+autoRoute.Name,
		"phase", autoRoute.Status.Phase,
	)

	switch autoRoute.Status.Phase {
	case "", v1.AutoRoutePhaseInitializing: // begin worker phase
		logger.Info("Syncing AutoRoute in phase Initializing", "name", autoRoute.Name)

		worker := &initializing.Worker{
			Client: client,
			Logger: logger,
		}
		nextPhase, statusInfo, err := worker.Sync(s.ctx, autoRoute)
		if err != nil {
			return result, fmt.Errorf("failed to run worker for phase Initializing: %v", err)
		}

		// update the AutoRoute status with the worker's results
		autoRoute.Status.Phase = nextPhase
		if statusInfo != nil {
			logger.Info("Updating status of primary resource")
			autoRoute.Status.AutoRouteStatusInfo = *statusInfo
		}
	case v1.AutoRoutePhaseSyncing: // begin worker phase
		logger.Info("Syncing AutoRoute in phase Syncing", "name", autoRoute.Name)

		worker := &syncing.Worker{
			Client: client,
			Logger: logger,
		}
		inputs, err := s.makeSyncingInputs(client)
		if err != nil {
			return result, fmt.Errorf("failed to make SyncingInputs: %v", err)
		}
		outputs, nextPhase, statusInfo, err := worker.Sync(s.ctx, autoRoute, inputs)
		if err != nil {
			return result, fmt.Errorf("failed to run worker for phase Syncing: %v", err)
		}
		for _, out := range outputs.Services.Items {
			if err := client.Ensure(s.ctx, autoRoute, &out); err != nil {
				return result, fmt.Errorf("failed to write output Service<%v.%v> for phase Syncing: %v", out.GetNamespace(), out.GetName(), err)
			}
		}
		for _, out := range outputs.VirtualServices.Items {
			if err := client.Ensure(s.ctx, autoRoute, &out); err != nil {
				return result, fmt.Errorf("failed to write output VirtualService<%v.%v> for phase Syncing: %v", out.GetNamespace(), out.GetName(), err)
			}
		}
		for _, out := range outputs.Gateways.Items {
			if err := client.Ensure(s.ctx, autoRoute, &out); err != nil {
				return result, fmt.Errorf("failed to write output Gateway<%v.%v> for phase Syncing: %v", out.GetNamespace(), out.GetName(), err)
			}
		}

		// update the AutoRoute status with the worker's results
		autoRoute.Status.Phase = nextPhase
		if statusInfo != nil {
			logger.Info("Updating status of primary resource")
			autoRoute.Status.AutoRouteStatusInfo = *statusInfo
		}
	case v1.AutoRoutePhaseReady: // begin worker phase
		logger.Info("Syncing AutoRoute in phase Ready", "name", autoRoute.Name)

		worker := &ready.Worker{
			Client: client,
			Logger: logger,
		}
		inputs, err := s.makeReadyInputs(client)
		if err != nil {
			return result, fmt.Errorf("failed to make ReadyInputs: %v", err)
		}
		nextPhase, statusInfo, err := worker.Sync(s.ctx, autoRoute, inputs)
		if err != nil {
			return result, fmt.Errorf("failed to run worker for phase Ready: %v", err)
		}

		// update the AutoRoute status with the worker's results
		autoRoute.Status.Phase = nextPhase
		if statusInfo != nil {
			logger.Info("Updating status of primary resource")
			autoRoute.Status.AutoRouteStatusInfo = *statusInfo
		} // end worker phase

	default:
		return result, fmt.Errorf("cannot process AutoRoute in unknown phase: %v", autoRoute.Status.Phase)
	}

	autoRoute.Status.ObservedGeneration = autoRoute.Generation

	if !reflect.DeepEqual(status, autoRoute.Status) {
		if err := client.UpdateStatus(s.ctx, autoRoute); err != nil {
			return result, fmt.Errorf("failed to update AutoRouteStatus: %v", err)
		}
	}

	return result, nil
}

func (s *Scheduler) makeSyncingInputs(client ezkube.Client) (syncing.Inputs, error) {
	var (
		inputs syncing.Inputs
		err    error
	)
	err = client.List(s.ctx, &inputs.Deployments, ctl.InNamespace(s.namespace))
	if err != nil {
		return inputs, err
	}

	return inputs, err
}

func (s *Scheduler) makeReadyInputs(client ezkube.Client) (ready.Inputs, error) {
	var (
		inputs ready.Inputs
		err    error
	)
	err = client.List(s.ctx, &inputs.Deployments, ctl.InNamespace(s.namespace))
	if err != nil {
		return inputs, err
	}

	return inputs, err
}
